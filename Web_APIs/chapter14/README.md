# Handling Authentication for our REST Services

## How simple authentication works

A client sends an authentication request to the server using user credentials.
The server takes those credentials and matches them with the credentials stored on the
server. If a match is successful, it writes something called a cookie in the response. This
cookie is a small piece of information that is transferred by the client for all subsequent
requests. Modern websites are being designed to be single-page applications (SPAs). In
those websites, static assets such as HTML and JavaScript files are served from a Content
Delivery Network (CDN) to render the web page initially. After that, the communication
between the web page and application server happens only through the REST API/web services.

A session records user communication in a given period of time whereby authentication information is stored in a cookie.

### Persisting client sessions with Redis

In order to persist session data between requests, we need to store this data
somewhere. One option is to use cookies or local storage.

Redis stores all the logged sessions using key-value pairs. It provides basic data types such as strings, lists, hashes.
Redis can serve the purpose of caching for your web applications.It can store temporary data such as session, frequently requested user content.
Redis is an in-memory data store, which means that it stores data in the RAM.

### Introducing JWT and OAuth2

JWT stands for JSON Web Tokens. It's a compact HTTP-friendly way to represent claims about an identity and an authenticated state.
Tokens can be any strings generated by the server, which allows the client to access resources by producing a token.
The token is computed in such a way that only the client and the server know how to encode/decode the token.
The token is a string of characters that is sent to the client after successful authentication.

#### JWT format

Steps for generating a JWT:

1. Create a JWT header by doing Base64Url encoding on the JSON header.
2. Create a JWT payload by doing Base64Url encoding on the JSON payload.
3. Create a signature by encrypting the appended header and payload using a secret key.
4. A JWT string can be obtained by appending the JWT header, JWT payload, and signature.

A header is a simple JSON object. It looks like the following code snippet in Go:
`{
"alg": "HS256",
"typ": "JWT"
}`

HS256 is a short form for the algorithm (HMAC with SHA-256) that's used for creating a
signature. The message type is JWT.

A payload looks like this:
`{
"sub": "1234567890",
"username": "Indiana Jones",
"admin": true
}`

Keys in a payload object are called claims. A claim is a key that specifies some special meaning to the server.
There are three types of claims:

- Reserved claims
- Private claims (more important)
- Public claims

_Reserved claims_ are the ones defined by the JWT standard:

- iat: Issued at the time
- iss: Issuer name
- sub: Subject text
- aud: Audience name
- exp: Expiration time

_Private claims_ are used to identify one token from another. They can be used for
authorization. Authorization is a process of identifying which client made the request.
Multi-tenancy refers to the situation of multiple clients accessing an API on a system.
The server can set a private claim called username on the payload of the token.
Next time, the server can read this payload back and get the username, and then use that username to authorize and customize the API response

_Public claims_ are similar to private claims, but they should be registered with the IANA
JWT Registry to make them as a standard

To generate a JWT, you need to know how to do base64url encoding. This means appending the encoded header, encoded payload, and signature to get our token
string, as follows:

`tokenString = base64UrlEncode(header) + "." + base64UrlEncode(payload) + "." + signature`

### JWT in an OAuth2.0 workflow
OAuth 2.0 is an authentication framework that is used to create an authentication pattern
between different systems. The client, instead of making a request to the resource
server, makes an initial request to an entity called *resource owner*. This resource owner
sends back the authentication grant for the client (if the credentials are authenticated). The
client now sends this authentication grant to another entity called an authentication server.
The authentication server takes the grant and returns an access token.

#### Authentication versus authorization
*Authentication* is the process of identifying whether a client is genuine or not. When a
server authenticates a client, it checks the username/password pair and creates a session
cookie/JWT.
*Authorization* is the process of evaluating whether a user has access to a given resource. In
cloud services, there should be a mechanism to limit the scope of resource access for certain
users/roles, and authorization enables it.
In simple words, authentication decides who is the customer of a service, and authorization
determines what are the customer's boundaries for resource access.

### Security aspects of an API

Factors to consider to secure a REST API:

* Always use HTTPS to deliver the API Transport Layer Security (TLS).
* Rate limit the API by using user access tokens.
* Design various authentication and authorization roles on the API.
* Use public key/private key encryption to sign a JWT when the client and server are internal.
* Never store user credentials in plain files.
* Sanitize the URL query parameters; use a POST body for incoming requests.
* As we mentioned in the previous chapter, use an API Gateway for better performance and protection.
* Use cloud services such as AWS Secrets Manager to store keys/passwords.
* Implement rate limiting at the application level.

